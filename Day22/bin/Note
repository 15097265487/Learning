 *	线程：
 *		进程可以进一步细化为线程，是一个程序内部的一条执行路径
 *	二、多线程的创建
 *	方式一、继承于Tread类
 *		1.创建一个子类的Tread类
 *		2.重写run()------>将此线程执行的操作声明
 *		3.创建Thread子类的对象
 *		4.创建该对象来调用start()
 *
 *	问题一：不能直接调用run()启动线程，需要调用start()
 *	问题二：不可以将一个线程启动多次，即再次调用start()----->(可以创建新的线程类的对象，调用start())
 *			  IllegalThreadStateException
 
 * 	线程Tread中常用方法
 * 		start():启动当前的线程，调用当前的线程run方法
 * 		run():通常需要重写Tread类中的run()方法，将创建线程要执行的任务放在该方法中
 * 		currentTread():静态方法，返回当前代码的线程
 * 		getName():获取当前线程的名字
 * 		setName():设置当前线程的名字
 * 		yield():让出执行权限,让其他线程得以优先执行,但其他线程能否优先执行是未知的
 * 		join():等待目标线程完成后再执行
 * 		stop():结束线程
 * 		sleep():该函数是Thread的静态函数,作用是使当前线程进入睡眠状态,因为其是静态方法,所以不会改变对象机锁,即使睡眠也持有对象锁,其他对象无法访问这个对象
 * 		isAlive():判断是否活着
 
  * 	设置线程的优先级：
 * 			MAX_PRIORITY: 线程可以具有的最高优先级。
 * 			MIN_PRIORITY: 线程可以具有的最低优先级。
			NORM_PRIORITY: 分配给线程的默认优先级。
		如何获取设置当前线程的优先级
			getPriority()
			setPriority(int p);
		说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上，并不是高优先级的线程执行完毕后在执行低优先级
 
 
  * 	1.问题：买票过程中出现的重票、错票------>线程安全问题
 * 		2.原因：某个线程操作车票时，操作还未完成，其他线程就参与进来，也操作车票
 * 		3.如何解决：当一个线程在操作车票时，其他线程不能参与进来，直到线程操作完成，其他线程才可以进来，
 * 				这种情况即使线程出现了阻塞，也不能改变
 * 		4.java中，通过同步机制，来解决线程安全问题
 * 
 * 			方式一：同步代码块
 * 				synchronized(同步监视器){
 * 					//需要被同步的代码
 * 				}
 * 				1.说明：操作共享数据代码，即为被同步代码块（不能包含代码多了，也不能包含代码少了）
 * 				2.共享数据：多个线程共同操作的对象，如ticket
 * 				3.同步监视器：俗称：锁
 * 					任何一个类的对象，都可以充当锁
 * 					要求：多个线程必须共用同一把锁	
 * 			注意：
 * 				①在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器 “类名.class”
 * 				②在实现Runnable接口创建多线程的方式中，我们可以考虑this充当同步监视器。
 * 			方式二：同步方法
 * 				如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的。
 * 				①同步方法仍然涉及同步监视器，只是不需要显示的放出来
 * 				②非静态的方法，同步监视器为this，静态方法，同步监视器为当前类本身
 * 		5.同步的方式，解决了线程的安全问题--------->好处
 * 		  操作同步代码时，只能有一个线程参与，其他线程等待，相当于一个单线程，效率低------->局限性
 
 *	 创建线程的第二种方法：实现Runnable
 *		1.创建一个实现Runnable接口的实现类
 *		2.实现类去实现Runnable中的抽象方法：run()
 *		3.创建实现类的对象
 *		4.将实现类的对象作为参数传递给Thread类构造器中，创建Thread类的对象
 *		5.通过Thread类的对象调用start()
 *
 *	比较创建线程的两种方式：
 *		开发中：优先选Runnable
 *		原因：1.类继承有局限性只可单继承，但可多实现
 *			2.实现的方式更适合处理多个线程有共享的数据情况
 *
 *		联系：class Tread implements Runnable
 *		相同：都需要从写Run()方法，将执行线程的逻辑声明在run()方法中
 *		区别：使用上一个是extends，另一个是implements
 */
 
 
 
 
 
 
 
 