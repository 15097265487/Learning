package cn.tedu.demo;
/*0、线程Thread中常用的方法：
 * 	1.start():启动当前线程，调用当前线程的run()
 *  2.run():通常需要重写Thread类中的run(),将创建线程要执行的任务放在此方法中
 *  3.currentThread():静态方法，返回执行当前代码的线程
 *  4.getName():获取当前线程名字
 *  5.setName():设置当前线程的名字
 *  6.yield():释放当前CPU的执行权
 *  7.join():在线程a中调用线程b的join(),此时线程a进入阻塞状态
 *  		直到线程b完全执行完以后，线程a才能结束阻塞状态。
 *  8.stop():已过时，
 *  9.sleep():让当前线程“睡眠”指定的毫秒，在指定毫秒时间内，
 *  			当前线程是阻塞状态
 *  10.isAlive():判断线程是否存活
 *  
 *  设置线程的优先级：
 *  MAX_PRIORITY:最高优先级。10
 *  MIN_PRIORITY:最低优先级。	1
 *  NORM_PRIORITY:	默认优先级---5
 * 2.如何获取设置当前线程的优先级
 * 	getPriority()
 * 	setPriority(int p);
 * 说明：高优先级的线程要抢占低优先级线程cpu的执行权，
 * 		但是只是从概率上，
 * 		并不是高优先级的线程执行完毕后在执行低优先级
 * 
 * 一、程序 进程 线程
 * 	程序：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。
 *	进程：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程。
 *	线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。
 * 二、创建及使用线程：
 * 	1.概述：
 * 	进程可进一步细化为线程，是一个程序内部的一条执行路径。
 *  2.多线程的创建
 *   	方式一：继承于Thread类
 *  		1.创建一个子类继承于Thread类
 *  		2.重写run()-->将此线程执行的操作声明在run()
 *  		3.创建Thread子类的对象
 *  		4.通过该对象调用start()
 *  	  问题一：不能直接调用run()启动线程，需要调用start()
 *  	  问题二：不可以将一个线程启动多次，即再次调用start()
 *  	  	报错：IllegalThreadStateException
 *  		但是可以创建一个新的线程类的对象，调用start()
 *  	方式二：实现Runnable
 * 			1.创建一个实现了Runnable接口的类
 * 			2.实现类去实现Runnable中的抽象方法：run()
 * 			3.创建实现类的对象
 * 			4.将实现类对象作为参数传递给Thread类的构造器中，
 * 	  			创建Thread类的对象
 * 			5.通过Thread类的对象调用start()
 * 
 * 	比较创建线程的两种方式：Thread Runnable
 * 		开发中，优先选Runnable
 * 		原因：1.类继承有局限性只可单继承，但可多实现
 * 	     	  2.实现的方式更适合处理多个线程有共享数据的情况
 * 
 * 	联系：class Thread implements Runnable
 * 	相同：都需要重写run(),将线程要执行的逻辑声明在run()中
 * 	区别：使用上一个是extends 一个是implements
 * 三、线程的生命周期
 *   两个概念：状态 对应的方法
 *   状态：新建-------->就绪------->运行------->死亡	
 * 				            阻塞
 *   方法：新建--->就绪： start()
 *              就绪--->运行：获取cpu的执行权
 *              运行--->就绪：失去cpu的执行权/yield()
 *              运行--->死亡：执行结束(run()执行完毕)
 *              	发生Error Exception且没有处理
 *                                      调用stop()
 *              运行---->阻塞：sleep(long ms)
 *          	  	join()
 *              	等待同步锁
 *              	wait()
 *              	suspend()
 *             阻塞--->就绪：sleep()中时间到
 *             	       在线程a中 b.join(),线程b执行结束后
 *             	       获得同步锁
 *                  resume()
 *   	阻塞是临时状态，死亡才是最终状态
 * 四、线程的同步(安全)
 * 1.问题：卖票过程中，出现了重票 错票-->线程安全问题
 * 2.原因：当某个线程操作车票过程中，操作尚未完成，
 * 			其他线程就参与进来，也操作车票。
 * 3.如何解决：当一个线程a在操作车票时，
 * 		其他线程不能参与进来，直到线程a操作完ticket时
 * 		其他线程才可以操作ticket，
 * 		这种情况即使线程a出现了阻塞，也不能被改变。
 * 4.java中，通过同步机制，来解决线程安全问题。
 * 	方式一：同步代码块
 * 		synchronized(同步监视器){
 * 			//需要 被同步的代码
 * 		}	
 * 	 说明：
 * 		1.操作共享数据代码，即为 被同步代码块
 * 			(不能包含代码多了，也不能包含代码少了)
 * 		2.共享数据：多个线程共同操作的对象，如ticket
 * 		3.同步监视器：俗称：锁。
 * 			任何一个类的对象，都可以充当锁。
 * 			要求：多个线程必须要共用同一把锁。
 * 		注意：
 * 		   ①在继承Thread类创建多线程的方式中，
 * 			慎用this充当同步监视器，
 * 			考虑使用当前类充当同步监视器，即类名.class
 *         ②在实现Runnable接口创建多线程的方式中，
 *         	我们可以考虑使用this充当同步监视器。
 * 		
 * 	方式二：同步方法
 * 		如果操作共享数据的代码完整的声明在一个方法中，
 * 			我们不妨将此方法声明为同步的。
 * 	   	①同步方法仍然涉及同步监视器(锁)，只是不需要我们显示的声明
 * 		②非静态的方法，同步监视器为this
 * 		  静态的方法，同步监视器为当前类本身	
 * 5.同步的方式，解决了线程的安全问题--好处
 * 	 操作同步代码时，只能有一个线程参与，其他线程等待
 * 		相当于一个单线程的过程，效率低--局限性。
 * 	方式三：lock锁
 * 		1.创建Lock实现类的对象
 * 			ReentrantLock lock = new ReentrantLock();
 * 		2.调用lock()方法：lock.lock();
 * 		3.调用解锁的方法：lock.unlock();
 *	方式四：使用线程池
 *		提高响应速度(减少了创建线程的时间)
 * 		降低资源消耗(重复利用线程池中线程，不需要每次都创建)
   	便于线程管理
			 corePoolSize：核心池的大小
   		 maximumPoolSize：最大线程数
 			 keepAliveTime：线程没有任务时最多保持多长时间后会终止
 *五、演示死锁问题：
 * 	1.理解：
 * 		不同的线程分别占用对方需要的同步资源不放弃，
 * 		都在等待对方放弃自己需要的同步资源，
 * 		就形成了线程的死锁
 * 	2.说明
 * 		2.1)出现死锁后不会出现异常，不会出现提示，
 * 			只是线程都处在阻塞的状态，无法继续执行
 * 		2.2)我们使用同步时，避免出现死锁
 * 		2.3)尽量减少同步资源的定义
 * 		2.4)尽量避免嵌套同步
 *六、线程通信
 *	1.涉及3个方法：
 * 		wait() 一旦执行到此方法，当前线程就会进入阻塞状态，并释放同步监视器
 *  	notify() 一旦执行到此方法,就会唤醒被wait()的线程，
 *  			如果有多个被wait的，则唤醒优先级高。
 *  	notifyAll() 一旦执行到此方法，就会唤醒所有被wait的线程
 *  2.使用说明：(注意)
 * 		wait() notify() notifyAll() 
 * 		① 三个方法必须使用在同步代码块或同步方法中。
 *  	② wait() notify() notifyAll() 三个方法的调用者
 *  	必须是同步代码块或同步方法中的
 *  	同步监视器
 *  	③ wait() notify() notifyAll()三个方法定义在Object中
 *七、创建线程的第三种方式：实现Callable接口
 *		1.创建一个实现类实现Callable
 *		2.实现call(),将线程需要执行的代码声明在call方法中
 *		3.创建Callable接口实现类的对象
 *		4.创建FutureTask类的对象，
 *			并将Callable接口实现类的对象作为参数
 *			传递到  FutureTask 的构造器中。
 *		(FutureTask<V> implements RunnableFuture<V>
 *		 RunnableFuture<V> extends Runnable, Future<V>)
 *		5.创建Thread类的对象
 *			并将FutureTask类的对象作为参数
 *			传递到 Thread 类的构造器中。
 *		  new Thread(FutureTask ft) 
 *		6.可选。获取Callable中call()的返回值
 *			Object futureTask.get()
 *    
 * 
 * 	单例模式之懒汉式--->线程安全的
 * 
 * 	面试题：
 * 	1.synchronized 与 Lock 的区别？
 * 		相同：二者都是解决线程安全问题
 *		区别：synchronized机制在执行完相应代码后，主动释放同步监视器
 *        		Lock需要手动的启动同步(lock()),
 *     				结束同步也需要手动实现(unlock())
 *        		synchronized有代码块锁和方法锁
 *        		Lock只有代码块锁
 *	2.sleep() 和 wait() 区别?
 * 		相同点：都可以使得线程进入阻塞状态。
 * 		不同点：
 * 			1)被wait()的线程需要使用notify()唤醒
 * 			  被sleep()的线程 时间到即结束阻塞状态
 * 			2)声明的位置：
 * 				Thread中声明sleep(),Object中声明wait()
 * 			3)使用位置：
 * 				sleep()可以在任意需要的场景下使用
 * 				wait()必须使用在同步代码块或同步方法中
 * 			4)是否会释放同步监视器(锁)
 * 			    (两个方法都使用在同步代码块或同步方法中)
 * 				sleep() 不会释放锁，wait()会释放锁
 */

import java.util.concurrent.Future;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.locks.ReentrantLock;

public class Review {
	
}

